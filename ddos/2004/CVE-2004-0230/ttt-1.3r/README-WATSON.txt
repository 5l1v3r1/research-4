includes.h
99,100c99
<       NUMTYPE_DECR,
<       NUMTYPE_WINDOW
---
>       NUMTYPE_DECR
131c130
< u_int32_t u_int32_next(struct u_int32_spec *spec, struct u_int16_spec *wsize);
---
> u_int32_t u_int32_next(struct u_int32_spec *spec);


numbers.c
52,56d51
< static int is_winsize(const char *spec)
< {
<       return spec[strlen(spec) - 1] == '^';
< }
<
293,297d287
<       } else if (is_winsize(number_spec) ) {
<               spec->current = strtoul(number_spec, NULL, 0);
<               spec->type = NUMTYPE_WINDOW;
<               spec->range_start = 0;
<               spec->range_end = 0;
307c297
< u_int32_t u_int32_next(struct u_int32_spec *spec, struct u_int16_spec *wsize)
---
> u_int32_t u_int32_next(struct u_int32_spec *spec)
337,339d326
<               case NUMTYPE_WINDOW:
<                       retval = spec->current+=wsize->current;
<                       break;

packet-factory.c
128,129c128,129
<       tcp->seq = u_int32_next(options.sequence_number,options.window);
<       tcp->ack_seq = u_int32_next(options.ack_seq,options.window);
---
>       tcp->seq = u_int32_next(options.sequence_number);
>       tcp->ack_seq = u_int32_next(options.ack_seq);

README
42,48d41
< For TCP Reset spoofing tests, specify a ^ after the sequence number.
< This will cause the sequence number to increase by the window size
< for each subsequent packet sent.
<
< -w 1024 -s 0^ (start with seq. 0, increase by 1k for each packet sent)
<
<
