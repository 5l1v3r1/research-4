/* SRVR.C V1.0 */

#if defined(BSD) || defined(SOLARIS)
#include <unistd.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#endif

#include <stdio.h>
#include <pcap.h>
#include <libnet.h>
#if !defined __FAVOR_BSD
#define __FAVOR_BSD
#endif
/*#include <netinet/ip.h>*/
#include <netinet/tcp.h>


struct in_addr dev_net,dev_mask,selected_ip;
u_int8_t outflags,inflags=0;
char outflagstr[30],inflagstr[30];
int i;
char *dev=NULL;
char *filter=NULL;
char pc_err[PCAP_ERRBUF_SIZE], bpf_commands[50];
struct bpf_program pcapfilter;
pcap_t *pcap_dev;
int snaplen=64, promisc=1, timeout=250, errorint=0, rawsock;
int count=0,ether_offset=14; /* we only support ethernet */

void errorout(const char *);

void callback_proc(u_char *data1, struct pcap_pkthdr* h, u_char *p);

int main(int argc, char *argv[])
{

if(argc < 3) {printf("USAGE: srvr -FSRPAUfsrpau listen-ip-address\n",
"Flags are for TCP flags FIN SYN RST PSH ACK URG, upper case incoming,\n",
"lower case outgoing.\n");exit(1);}

if (!(inet_aton(argv[2],&selected_ip))) errorout("NOT and IP address\n");

while (( i = getopt(argc,argv,"FSRPAUfsrpau")) != EOF)
  switch (i) {
	case 'F': {inflags |= TH_FIN; i_flagadd("FIN");break;}
	case 'S': {inflags |= TH_SYN; i_flagadd("SYN");break;}
	case 'R': {inflags |= TH_RST; i_flagadd("RST");break;}
	case 'P': {inflags |= TH_PUSH; i_flagadd("PSH");break;}
	case 'A': {inflags |= TH_ACK; i_flagadd("ACK");break;}
	case 'U': {inflags |= TH_URG; i_flagadd("URG");break;}
	case 'f': {outflags |= TH_FIN; o_flagadd("FIN");break;}
	case 's': {outflags |= TH_SYN; o_flagadd("SYN");break;}
	case 'r': {outflags |= TH_RST; o_flagadd("RST");break;}
	case 'p': {outflags |= TH_PUSH; o_flagadd("PSH");break;}
	case 'a': {outflags |= TH_ACK; o_flagadd("ACK");break;}
	case 'u': {outflags |= TH_URG; o_flagadd("URG");break;}
	}

if(!(dev=pcap_lookupdev(pc_err)))
	{errorout("pcap_lookupdev");}

if(!(pcap_dev=pcap_open_live(dev,snaplen,promisc,timeout,pc_err)))
	{errorout("pcap_open_live");}

if(pcap_lookupnet(dev,&dev_net.s_addr,&dev_mask.s_addr,pc_err) == -1)
	{errorout("pcap_lookupnet");}

snprintf(bpf_commands,50,"tcp[13] & %i = %i and host %s",
	inflags,inflags,argv[2]);

if(pcap_compile(pcap_dev,&pcapfilter,bpf_commands, 0,
	dev_mask.s_addr) == -1)
	{errorout("pcap_compile");}


if(pcap_setfilter(pcap_dev,&pcapfilter)==-1)
	{errorout("pcap_setfilter");}

rawsock=libnet_open_raw_sock(IPPROTO_RAW);
if (rawsock == -1) errorout("can't open raw socket!\n");

printf("\nListening for TCP packets with flags%s and sending%s in response.\n",
	inflagstr,outflagstr);

while(pcap_loop(pcap_dev,0,(pcap_handler)callback_proc,0));
return(0);
}


 void callback_proc(u_char *data1, struct pcap_pkthdr* h, u_char *p)
 { 
	struct ip* as_ip=(struct ip *)(p + ether_offset);
	u_int16_t ip_hl=as_ip->ip_hl*4;
	if(as_ip->ip_p == IPPROTO_TCP)
	{
	struct tcphdr* as_tcp = (struct tcphdr *)(((char *)as_ip)+ip_hl);
	
	printf("%s from %s:%d",inflagstr,inet_ntoa(as_ip->ip_src),
		ntohs(as_tcp->th_sport));
	printf(" to %s:%d\n", inet_ntoa(as_ip->ip_dst),
		ntohs(as_tcp->th_dport));
	printf("SEQ: %lu ACK: %lu COUNT: %i\n", (u_int32_t
	)as_tcp->th_seq, (u_int32_t)as_tcp->th_ack, count++);
  
	/* libnet stuff to send ack/fin */


libnet_build_ip(TCP_H, IPTOS_LOWDELAY, 413, 0, 67, IPPROTO_TCP, 
	(u_int32_t)as_ip->ip_dst.s_addr,
	(u_int32_t)as_ip->ip_src.s_addr,
	NULL, 0, p + ether_offset);
                                                      
libnet_build_tcp(
	htons(as_tcp->th_dport),
	htons(as_tcp->th_sport),
	htonl(as_tcp->th_ack),
	htonl(as_tcp->th_seq)+1,
	 outflags, 512, 0,
	NULL, 0, p + ether_offset + IP_H);

libnet_do_checksum(p + ether_offset, IPPROTO_TCP, IP_H);

errorint=libnet_write_ip(rawsock, p + ether_offset, TCP_H + IP_H);

if (errorint < TCP_H + IP_H) {
	errorout("Can't send packet! (libnet_write_ip)\n");
	};

 } /* end of callback */


} /* end of main */


void errorout(const char *errorstr)
{
 printf("ERROR: %s\n",errorstr);
 exit(-1);
}

int i_flagadd(char *flag)
{
 sprintf(inflagstr,"%s %s",inflagstr,flag);
}

int o_flagadd(char *flag)
{
 sprintf(outflagstr,"%s %s",outflagstr,flag);
}

